import re, sys

# Contents of ufunc.txt must be written in the following order:
#   1) signature
#   2) returntype: optional
#   3) cppexpression
#   4) description
# Lines in ufunc.txt can be of other category, such as:
#   a) equivalent
#   b) section
#   c) comment

signature     = re.compile(r'^(\w+)\((.+)\)$', re.MULTILINE)
returntype    = re.compile(r'^ret\[(.+)\]')
cppexpression = re.compile(r'^cpp\[(.+)\]')
description   = re.compile(r'^\w.*\.$', re.MULTILINE)
equivalent    = re.compile(r'^eq\[(.+)\]')
section       = re.compile(r'^\w+$')
comment       = re.compile(r'^#.*')

def main(source, target):
    with open(source) as f, open(target, 'w') as g:
        g.write("// This is auto-generated by ufunc_generate.py and ufunc.txt. Do not edit.\n")
        g.write("// reference : https://numpy.org/doc/stable/reference/ufuncs.html\n\n")
        g.write("#pragma once\n\n#include <cmath>\n#include <numeric>\n\n")
        g.write("namespace numpy {\n  namespace _ufunc_internal {\n\n")

        decls = []
        
        for line in f:
            sig = signature.match(line)
            ret = returntype.match(line)
            cpp = cppexpression.match(line)
            des = description.match(line)
            eq  = equivalent.match(line)
            sec = section.match(line)
            com = comment.match(line)

            if com:
                continue

            elif sig:
                name, args = sig.groups()
                binary = 'x1, x2' in args
                unary = not binary and 'x' in args
                rettype = None

                if unary:
                    decls += [f'  constexpr ufunc_unary<_ufunc_internal::_{name}> {name};']
                elif binary:
                    decls += [f'  constexpr ufunc_binary<_ufunc_internal::_{name}> {name};']
                else:
                    raise Exception(f'{name} is neither unary or binary?')

            elif ret:
                rettype, = ret.groups()
                
            elif cpp:
                cppexp, = cpp.groups()
                if rettype is None:
                    rettype = f"decltype({cppexp})"
                if unary:
                    g.write("\n".join([
                         "    template <class Type>",
                        f"    struct _{name} {{",
                        f"      constexpr _{name}() = default;",
                        f"      auto operator()(Type x) -> {rettype} const {{",
                        f"        return {cppexp};",
                         "      }",
                         "    };\n\n"
                    ]))
                elif binary:
                    g.write("\n".join([
                         "    template <class Type1, class Type2>",
                        f"    struct _{name} {{",
                        f"      constexpr _{name}() = default;",
                        f"      auto operator()(Type1 x1, Type2 x2) -> {rettype} const {{",
                        f"        return {cppexp};",
                         "      }",
                         "    };\n\n"
                    ]))

            elif eq:
                decls[-1] = f"  constexpr auto {name} = {eq.groups()[0]};"
                    
            elif des:
                decls += ['\t// ' + des.group() + '\n']

            elif sec:
                decls += [f'\n\n    /{f" {sec.group()} ":*^80}/\n']

        g.write("  } // namespace _ufunc_internal\n\n")
        decls += ["\n} // namespace numpy\n"]
        g.write("".join(decls))

if __name__ == '__main__':
    if len(sys.argv) != 3:
        print(f"usage: python {sys.argv[0]} [source] [target]")
        sys.exit(1)
    main(sys.argv[1], sys.argv[2])
    
